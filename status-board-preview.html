<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>äº¤æ˜“ç»„ä»¶ç›‘æ§é¢æ¿ - é¢„è§ˆç‰ˆ</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background-color: #f9fafb;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #2d3748;
    }
    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      justify-content: space-between;
    }
    input[type="text"] {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 200px;
    }
    button {
      padding: 6px 12px;
      background: #4f46e5;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #4338ca;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow: hidden;
    }
    th, td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid #edf2f7;
    }
    th {
      background-color: #f8fafc;
      font-weight: 600;
      color: #4a5568;
    }
    tr:hover {
      background-color: #f8fafc;
    }
    .status-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .ok { background-color: #10b981; }      /* green */
    .error { background-color: #ef4444; }   /* red */
    .warning { background-color: #f59e0b; } /* amber */
    .healthy::before { content: "ğŸŸ¢"; }
    .unhealthy::before { content: "ğŸ”´"; }
    .timestamp {
      font-size: 0.85em;
      color: #718096;
    }
    .file-path {
      font-family: monospace;
      background: #f1f5f9;
      padding: 2px 4px;
      border-radius: 3px;
    }
    .last-update {
      text-align: right;
      font-size: 0.9em;
      color: #64748b;
      margin-top: 12px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="container">
      <h1>äº¤æ˜“ç»„ä»¶ç›‘æ§é¢æ¿</h1>

      <div class="controls">
        <input v-model="searchQuery" placeholder="æœç´¢ç»„ä»¶ ID..." />
        <button @click="refresh">ğŸ”„ æ‰‹åŠ¨åˆ·æ–°</button>
      </div>

      <table>
        <thead>
          <tr>
            <th>ç»„ä»¶ ID</th>
            <th>å¿ƒè·³çŠ¶æ€</th>
            <th>æ–‡ä»¶æ›´æ–°</th>
            <th>è¿è¡Œç­‰çº§</th>
            <th>æ•´ä½“å¥åº·</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="comp in filteredComponents" :key="comp.id">
            <td>{{ comp.id }}</td>
            <td>
              <span :class="['status-dot', comp.heartbeat.ok ? 'ok' : 'error']"></span>
              {{ comp.heartbeat.ok ? 'å­˜æ´»' : 'å®•æœº' }}
              <div class="timestamp" v-if="comp.heartbeat.lastSeen">
                {{ formatTime(comp.heartbeat.lastSeen) }}
              </div>
            </td>
            <td>
              <template v-if="comp.file_status">
                <div v-for="(file, idx) in getAllFiles(comp.file_status)" :key="idx">
                  <span :class="['status-dot', file.ok ? 'ok' : 'error']"></span>
                  {{ file.type }}:
                  <span class="file-path" :title="file.path">{{ getFileName(file.path) }}</span>
                  <div class="timestamp" v-if="file.last_mtime">
                    {{ formatTime(file.last_mtime) }}
                  </div>
                </div>
              </template>
              <span v-else>â€”</span>
            </td>
            <td>
              <span v-if="comp.level_status">
                <span :class="['status-dot', comp.level_status.compliant ? 'ok' : 'error']"></span>
                å®é™…: {{ comp.level_status.observed_level || comp.level_status.declared_level || '?' }} / 
                æœŸæœ›: {{ comp.level_status.expected_level }}
                {{ comp.level_status.compliant ? 'åˆè§„' : 'è¿è§„' }}
              </span>
              <span v-else>â€”</span>
            </td>
            <td :class="comp.overallHealthy ? 'healthy' : 'unhealthy'"></td>
          </tr>
        </tbody>
      </table>

      <div class="last-update">æœ€åæ›´æ–°: {{ lastUpdateTime }}</div>
    </div>
  </div>

  <script>
    const { createApp, ref, computed, onMounted } = Vue

    // æ¨¡æ‹Ÿä½ å½“å‰çš„çœŸå®æ•°æ®
    const mockData = {
      "market_data_feeder": {
        heartbeat: { ok: true, lastSeen: "2026-02-23T17:32:00Z" },
        file_status: {
          input_files: {
            "./data/market_data.csv": {
              ok: true,
              last_mtime: "2026-02-23T17:31:45Z",
              expected_cron: "*/5 * * * *"
            }
          },
          output_files: {}
        },
        level_status: {
          expected_level: 2,
          declared_level: 2,
          compliant: true
        }
      },
      "risk_checker": {
        heartbeat: { ok: true, lastSeen: "2026-02-23T17:32:10Z" },
        file_status: {
          input_files: {
            "./data/risk_input.txt": {
              ok: false,
              last_mtime: "2026-02-23T17:20:00Z",
              error: "File not updated in time"
            }
          },
          output_files: {}
        },
        level_status: {
          expected_level: 2,
          declared_level: 4,
          compliant: false
        }
      },
      "trade_engine": {
        heartbeat: { ok: true, lastSeen: "2026-02-23T17:32:05Z" },
        file_status: {
          input_files: {
            "./data/trade_input.json": {
              ok: false,
              last_mtime: "2026-02-23T17:15:00Z",
              error: "Stale file"
            }
          },
          output_files: {}
        },
        level_status: {
          expected_level: 1,
          declared_level: 4,
          compliant: false
        }
      }
    }

    createApp({
      setup() {
        const searchQuery = ref('')
        const lastUpdateTime = ref('â€”')
        const rawData = ref({})

        const components = computed(() => {
          return Object.entries(rawData.value).map(([id, data]) => {
            const heartbeat = data.heartbeat || { ok: false }
            const file_status = data.file_status
            const level_status = data.level_status

            // è®¡ç®—æ•´ä½“å¥åº·
            const hbOk = heartbeat.ok === true
            const fileOk = !file_status || (
              Object.values(file_status.input_files || {}).every(f => f.ok) &&
              Object.values(file_status.output_files || {}).every(f => f.ok)
            )
            const levelOk = level_status?.compliant !== false

            return {
              id,
              heartbeat,
              file_status,
              level_status,
              overallHealthy: hbOk && fileOk && levelOk
            }
          }).sort((a, b) => (b.overallHealthy - a.overallHealthy)) // å¼‚å¸¸åœ¨å‰
        })

        const filteredComponents = computed(() => {
          return components.value.filter(comp =>
            comp.id.toLowerCase().includes(searchQuery.value.toLowerCase())
          )
        })

        const getAllFiles = (fs) => {
          const files = []
          if (fs.input_files) {
            for (const [path, info] of Object.entries(fs.input_files)) {
              files.push({ ...info, path, type: 'è¾“å…¥' })
            }
          }
          if (fs.output_files) {
            for (const [path, info] of Object.entries(fs.output_files)) {
              files.push({ ...info, path, type: 'è¾“å‡º' })
            }
          }
          return files
        }

        const getFileName = (path) => path.split('/').pop()

        const formatTime = (isoStr) => {
          return new Date(isoStr).toLocaleString('zh-CN')
        }

        const fetchData = () => {
          // ä½¿ç”¨ mock æ•°æ®ï¼ˆæ›¿æ¢ä¸ºçœŸå® fetch é€»è¾‘å³å¯å¯¹æ¥åç«¯ï¼‰
          rawData.value = mockData
          lastUpdateTime.value = new Date().toLocaleTimeString('zh-CN')
        }

        const refresh = () => {
          fetchData()
        }

        onMounted(() => {
          fetchData()
          setInterval(fetchData, 10000)
        })

        return {
          searchQuery,
          lastUpdateTime,
          filteredComponents,
          getAllFiles,
          getFileName,
          formatTime,
          refresh
        }
      }
    }).mount('#app')
  </script>
</body>
</html>